{
  "name": "KnowItAll",
  "tagline": "Minimalistic authorization focused on APIs",
  "body": "> Well, actually...\r\n\r\n# KnowItAll\r\n\r\n[![Gem Version](https://badge.fury.io/rb/know_it_all.svg)](https://badge.fury.io/rb/know_it_all)\r\n[![Join the chat at https://gitter.im/mrodrigues/know_it_all](https://badges.gitter.im/mrodrigues/know_it_all.svg)](https://gitter.im/mrodrigues/know_it_all?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nKnowItAll is a small, object-oriented approach to authorization. It knows everything about your application!\r\n\r\nMore of an architectural pattern for API-focused authorization than properly a dependency, and heavily inspired by [Pundit](https://github.com/elabs/pundit), this gem simply provides a small set of helpers that make applying the pattern easier.\r\n\r\nIf your application needs to validate pre-requisites before performing certain actions, at the same time providing helpful error messages for the API's clients, all that while using regular magic-less Ruby and object oriented design patterns, KnowItAll is your friend.\r\n\r\nTable of Contents\r\n=================\r\n\r\n  * [KnowItAll](#knowitall)\r\n    * [Why?](#why)\r\n    * [Why not just Pundit?](#why-not-just-pundit)\r\n    * [Installation](#installation)\r\n    * [Usage](#usage)\r\n      * [Creating policies](#creating-policies)\r\n        * [Naming convention](#naming-convention)\r\n        * [Helper class](#helper-class)\r\n      * [Using policies](#using-policies)\r\n        * [What happens when not authorized](#what-happens-when-not-authorized)\r\n        * [Querying authorizations in the view](#querying-authorizations-in-the-view)\r\n        * [Avoiding conflicts in the controller](#avoiding-conflicts-in-the-controller)\r\n        * [Overrides](#overrides)\r\n    * [Enforcing authorization checks](#enforcing-authorization-checks)\r\n    * [Development](#development)\r\n    * [Contributing](#contributing)\r\n    * [License](#license)\r\n\r\n## Why?\r\n\r\nThe assumption made is that each action has its own requirements based on the current context. Some may be related to the current user's permissions in the system, others with the parameters sent, and others yet may even have nothing to do with any input received. Let's say you're building the API for a food delivery app. To be able to checkout, you need to validate the following requirements:\r\n\r\n- The user must be signed in;\r\n- The user must have a registered address;\r\n- The registered address must be within a determined radius;\r\n- The cart must contain at least $10 in items;\r\n- The chosen items must be available for delivery;\r\n- The store must be open.\r\n\r\nIt'd be very helpful for a developer consuming this API if, in case of failure, the API returned an appropriate error message explaining exactly what when wrong, instead of an empty `403 Forbidden`. Performing this manually is easy, but quickly polutes the action's code:\r\n\r\n```ruby\r\nclass OrdersController < ApplicationController\r\n  def create\r\n    return error(\"User must be signed in\") unless current_user\r\n    return error(\"User must have a registered address\") unless current_user.address\r\n    return error(\"Registered address is outside the range\") unless address_in_range?(current_user.address)\r\n    return error(\"Cart must contain at least $10 in items\") unless cart_has_minimum?(cart)\r\n    return error(\"Some of the items are not available\") unless items_available?(cart.items)\r\n    return error(\"The store is closed\") unless store.open?\r\n\r\n    # Here finally starts what the action actually does\r\n    order = Order.create(order_params)\r\n    if order.save\r\n      render json: order, status: :created\r\n    else\r\n      render json: { errors: order.errors }, status: :unprocessable_entity\r\n    end\r\n  end\r\n\r\n  private\r\n\r\n    def error(message)\r\n      render json: { error: message }, status: :forbidden\r\n    end\r\nend\r\n```\r\n\r\nIt's much more readable, as well as easier to test and extend, if all of those requirement tests were contained in a proper class:\r\n\r\n```ruby\r\nclass OrdersController < ApplicationController\r\n  def create\r\n    policy = OrdersPolicies::Create.new(current_user, cart, store)\r\n    return render json: { errors: policy.errors } unless policy.authorize?\r\n\r\n    order = Order.create(order_params)\r\n    if order.save\r\n      render json: order, status: :created\r\n    else\r\n      render json: { errors: order.errors }, status: :unprocessable_entity\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThat's exactly the architectural pattern encouraged by this gem. By including a small set of helpers, it makes it extremely simple to perform complex validations and provide helpful feedback through the API.\r\n\r\n## Why not just Pundit?\r\n\r\nPundit is great! I've been using it for years and I love it, but its model-focused permissions and structural pattern makes it difficult and awkward to perform validations on scenarios that need multiple arguments and show appropriate error messages for the API's clients. Based on modifications I've made when using Pundit in some projects, I created this gem.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'know_it_all'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install know_it_all\r\n\r\n## Usage\r\n\r\nThere are two steps to using this gem: creating and using policies:\r\n\r\n### Creating policies\r\n\r\nA policy is simply a class obeys some rules:\r\n\r\n* It is initialized with the same arguments that are passed to the `authorize`, `authorize!` and `authorize?` methods in the controller;\r\n* It responds to a method `errors`;\r\n* Calling `errors` returns an object that responds to the method `empty?` and is serializable. It's usually an array, but it could easily be an `ActiveModel::Errors`.\r\n\r\nHere's an example:\r\n\r\n```ruby\r\nmodule OrdersPolicies\r\n  class Create\r\n    def initialize(current_user, cart, store)\r\n      @current_user = current_user\r\n      @cart = cart\r\n      @store = store\r\n    end\r\n\r\n    def errors\r\n      @errors = []\r\n      @errors << \"User must be signed in\" unless @current_user\r\n      @errors << \"User must have a registered address\" unless @current_user.address\r\n      @errors << \"Registered address is outside the range\" unless address_in_range?(current_user.address)\r\n      @errors << \"Cart must contain at least $10 in items\" unless cart_has_minimum?(@cart)\r\n      @errors << \"Some of the items are not available\" unless items_available?(@cart.items)\r\n      @errors << \"The store is closed\" unless @store.open?\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nUsing `ActiveModel::Validations`:\r\n\r\n```ruby\r\nmodule OrdersPolicies\r\n  class Create\r\n    include ActiveModel::Validations\r\n\r\n    validates_presence_of :current_user, :address\r\n    validate :address_in_range\r\n    validate :cart_has_minimum\r\n    validate :items_are_available\r\n    validate :store_is_open\r\n\r\n    def initialize(current_user, cart, store)\r\n      @current_user = current_user\r\n      @cart = cart\r\n      @store = store\r\n\r\n      run_validations! # Populates the `ActiveModel::Errors`\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### Naming convention\r\n\r\nThe convention `KnowItAll` uses for defining the name of the constant containing the appropriate policy is the following:\r\n\r\n* Based on the `controller_path` method on the controller, it builds a module name by appending the `Policies` suffix: `\"orders\"` becomes `\"OrdersPolicies\"` and `\"admin/dashboard_panel\"` becomes `\"Admin::DashboardPanelPolicies\"`.\r\n* Based on the `action_name` method on the controller, it builds a class name: `\"index\"` becomes `\"Index\"`, `\"increase_inventory\"` becomes `\"IncreaseInventory\"`.\r\n* By appending the class name to the module name, it tries to find that constant: with `controller_path == \"orders\"` and `action_name == \"Index\"`, it looks for a `OrdersPolicies::Index` constant.\r\n\r\nFor more details about how the module and class names are converted, please check the [`ActiveSupport::Inflector#camelize`](http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-camelize) method.\r\n\r\n#### Helper class\r\n\r\nIf you don't want to write your own policy from the scratch, I've also provided a minimalistic base policy:\r\n\r\n```ruby\r\nmodule OrdersPolicies\r\n  class Create < KnowItAll::Base\r\n    assert :user_signed_in?, \"User must be signed in\" \r\n    assert :address_present?, \"User must have a registered address\" \r\n    assert :address_in_range?, \"Registered address is outside the range\" \r\n    assert :cart_has_minimum?, \"Cart must contain at least $10 in items\" \r\n    assert :items_available?, \"Some of the items are not available\" \r\n    assert :store_open?, \"The store is closed\" \r\n\r\n    def initialize(current_user, cart, store)\r\n      @current_user = current_user\r\n      @cart = cart\r\n      @store = store\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe class method `assert` expects a `Symbol` representing the name of a predicate and a `String` containing the error message in case the predicate fails. The default `errors` method returns an array containing the messages for all the assertions that didn't pass.\r\n\r\nIn case you need to define dynamically the error message (e.g. for internationalization), the `assert` method also accepts any object that responds to `call`, as a lambda. It'll pass the policy itself as an argument:\r\n\r\n```ruby\r\nmodule OrdersPolicies\r\n  class Create < KnowItAll::Base\r\n    attr_reader :cart\r\n\r\n    assert :cart_has_minimum?, -> (policy) {\r\n      I18n.t(:cart_minimum_total_error, total: policy.cart.total)\r\n    }\r\n\r\n    def initialize(cart)\r\n      @cart = cart\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n### Using policies\r\n\r\nThe simplest approach is to include the `KnowItAll` module in the controller you want to perform the validation. For this example, let's make the helpers available to all controllers by including it in the `ApplicationController`:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  include KnowItAll\r\nend\r\n```\r\n\r\nAfter that, we can use the helpers in any controller that inherits from `ApplicationController`:\r\n\r\n```ruby\r\nclass OrdersController < ApplicationController\r\n  def create\r\n    authorize! current_user, cart, store\r\n\r\n    order = Order.create(order_params)\r\n    if order.save\r\n      render json: order, status: :created\r\n    else\r\n      render json: { errors: order.errors }, status: :unprocessable_entity\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### What happens when not authorized\r\n\r\nThe `authorize!` method raises a `KnowItAll::NotAuthorized` exception in case the authorization has failed, and contains the instance of the policy used to perform the validation:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  include KnowItAll\r\n  rescue_from KnowItAll::NotAuthorized do |exception|\r\n    render json: { errors: exception.policy.errors }, status: :forbidden\r\n  end\r\nend\r\n```\r\n\r\nThis pattern is so common that I've wrote a method that does exactly that:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  include KnowItAll\r\n  rescue_from KnowItAll::NotAuthorized, with: :render_not_authorized\r\nend\r\n```\r\n\r\nAlternatively, you can use the bangless form of the authorization method (`authorize`), which doesn't raise an exception and returns the errors in the policy:\r\n\r\n```ruby\r\nclass OrdersController < ApplicationController\r\n  def create\r\n    errors = authorize current_user, cart, store\r\n    if errors.empty?\r\n      order = Order.create(order_params)\r\n      if order.save\r\n        render json: order, status: :created\r\n      else\r\n        render json: { errors: order.errors }, status: :unprocessable_entity\r\n      end\r\n    else\r\n      return render json: { errors: errors }, status: :forbidden\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### Querying authorizations in the view\r\n\r\nYou can use the predicate `authorize?` to make decisions based on future authorizations in your views. First you need to make the method available as a helper:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  include KnowItAll\r\n  helper_method :authorize?\r\nend\r\n```\r\n\r\nThen use it in your views, passing the appropriate overrides (more about that here):\r\n\r\n```erb\r\n<%= form_for @order do |f| %>\r\n  <!-- Form fields -->\r\n\r\n  <%= f.button \"Place order\", disabled: authorize?(\r\n                                          @current_user,\r\n                                          @cart,\r\n                                          @store,\r\n                                          controller_path: \"orders\",\r\n                                          action_name: \"create\"\r\n                                        ) %>\r\n<% end %>\r\n```\r\n\r\n#### Avoiding conflicts in the controller\r\n\r\nIt's possible that you're already using methods with the same names as the ones in the `KnowItAll` module: `authorize`, `authorize?`, `authorize!`, `policy`, `policy_class`, `policy_name`, `render_not_authorized` or `verify_authorized`. In that case, the solution is to include the module in another class, and use it as a collaborator. The only methods `KnowItAll` needs to find the correct policies are `controller_path` and `action_name`:\r\n\r\n```ruby\r\nclass Authorizer\r\n  include KnowItAll\r\n  attr_reader :controller_path, :action_name\r\n\r\n  def initialize(controller)\r\n    @controller_path = controller.controller_path\r\n    @action_name = controller.action_name\r\n  end\r\nend\r\n\r\nclass ApplicationController < ActionController::Base\r\n  protected\r\n\r\n    def authorizer\r\n      Authorizer.new(self)\r\n    end\r\nend\r\n\r\nclass OrdersController < ApplicationController\r\n  def create\r\n    authorizer.authorize! current_user, cart, store\r\n\r\n    # Action's code here\r\n  end\r\nend\r\n```\r\n\r\nIn that case, I've made available a `KnowItAll::Authorizer` class that does exactly that:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  protected\r\n\r\n    def authorizer\r\n      KnowItAll::Authorizer.new(self)\r\n    end\r\nend\r\n```\r\n\r\n#### Overrides\r\n\r\nIt's possible to override any of the methods `KnowItAll` uses to define the appropriate policy. You can do that in the controller:\r\n\r\n```ruby\r\nclass OrdersController < ApplicationController\r\n  def create\r\n    authorize! current_user, cart, store\r\n\r\n    # Action's code here\r\n  end\r\n\r\n  def policy_name\r\n    \"OrdersPolicies::Checkout\"\r\n  end\r\nend\r\n```\r\n\r\nOr when calling the `authorize`, `authorize?` or `authorize!` methods:\r\n\r\n```ruby\r\nclass OrdersController < ApplicationController\r\n  def create\r\n    authorize! current_user, cart, store, policy_name: \"OrdersPolicies::Checkout\"\r\n\r\n    # Action's code here\r\n  end\r\nend\r\n```\r\n\r\nThe available overrides are: `controller_path`, `action_name`, `policy_name`, `policy_class` and `policy` (instance of the policy).\r\n\r\n## Enforcing authorization checks\r\n\r\nWhile developing a simple feature, it's easy to forget to perform an authorization check. It's helpful during development to know when you forget it, so I've provided a `verify_authorized` method that raises a `KnowItAll::AuthorizationNotPerformedError` when there were no calls to any one of the authorization methods: `authorize`, `authorize?` or `authorize!`:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  include KnowItAll\r\n  after_action :verify_authorized\r\nend\r\n```\r\n\r\n## Development\r\n\r\nAfter checking out the repo, run `bin/setup` to install dependencies. Then, run `rake test` to run the tests. You can also run `bin/console` for an interactive prompt that will allow you to experiment.\r\n\r\nTo install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).\r\n\r\n## Contributing\r\n\r\nBug reports and pull requests are welcome on GitHub at https://github.com/mrodrigues/know_it_all. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the [Contributor Covenant](contributor-covenant.org) code of conduct.\r\n\r\n\r\n## License\r\n\r\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}